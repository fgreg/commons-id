/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.id.uuid.clock;

import junit.framework.TestCase;

import java.util.Arrays;

/**
 * Unit tests for {@link SystemClockImplTest}.
 *
 * @author Commons-Id team
 * @version $Revision: 480488 $ $Date: 2006-11-29 00:57:26 -0800 (Wed, 29 Nov 2006) $
 */
public class SystemClockImplTest extends TestCase {

    /** Constant for System.property os.name */
    public static final String SYS_OS_NAME_PROPERTY = "os.name";

    /** Constant for Windows */
    public static final String SYS_OS_WINDOWS = "Windows";

    /** Indicates if the OS is windows */
    private static boolean isWindows = false;

    protected void setUp() throws Exception {
        super.setUp();
        if (System.getProperty(SYS_OS_NAME_PROPERTY).indexOf(SYS_OS_WINDOWS) > -1) {
            isWindows = true;
        }
    }

    /**
     * Make sure that time stamps generated by concurrent threads
     * are unique.
     *
     * @throws Exception a testing exception.
     */
    public void testUnique() throws Exception {
        //Return if this is not Windows OS
        if (!isWindows) {
            return;
        }

        /*
         * Number of timestamps to generate on each client
         */
        int iterations = 11000;

        /*
         * Number of client threads
         */
        int threadCount = 4;

        // Launch threadCount client threads and set them
        // off generating time stamps
        long[][] threadTimes = new long[threadCount][iterations];
        Thread[] clockClients = new Thread[threadCount];

        for (int i = 0; i < threadCount; i++) {
            clockClients[i] = new ClockClient(threadTimes[i], iterations);
            clockClients[i].start();
        }

        // Wait until all the threads are done
        boolean working = true;
        while (working) {
            working = false;
            for (int i = 0; i < threadCount; i++) {
                if (clockClients[i].isAlive()) {
                    working = true;
                }
            }
        }

        // Check for duplicates within each client
        // Ridiculously inefficient, but effective -- sort and walk
        for (int j = 0; j < threadTimes.length; j++) {
            Arrays.sort(threadTimes[j]);
            for (int i = 0; i < threadTimes.length - 1; i++) {
                if (threadTimes[j][i] == threadTimes[j][i + 1]) {
                    fail( "Duplicate time stamps generated: " + threadTimes[j][i] + " " + i);
                }
            }
        }
    }

    /**
     * Make sure that generated time stamps are within expected ranges.
     * Tolerance is now 1 seconds
     *
     * @throws Exception any test Exception.
     */
    public void testRange() throws Exception {
        if (!isWindows) {
            return;
        }
        long time = 0;
        long baseTime = 0;
        Clock c = new SystemClockImpl();
        for (int i = 0; i < 100; i++) {
            Thread.currentThread().sleep(10);
            for (int j = 0; j < 100; j++) {
                try {
                    baseTime = System.currentTimeMillis();
                    time = c.getUUIDTime();
                    assertTrue( "Generated timestamp too large", time < ((baseTime + Clock.GREGORIAN_CHANGE_OFFSET + 1000)
                                * Clock.INTERVALS_PER_MILLI));

                    assertTrue("Generated timestamp too small", time > ((baseTime + Clock.GREGORIAN_CHANGE_OFFSET - 1000)
                                * Clock.INTERVALS_PER_MILLI));
                } catch (OverClockedException oce) {
                    //Nothing to do
                }
            }
        }
    }

    //--------------------------------------------------------------------------
    /**
     * Clock client thread
     */
    protected static class ClockClient extends Thread {
        /** Counter for the number of over clockings */
        private static int overClocks;

        /** The clock instance to use */
        private Clock c = new SystemClockImpl();

        /**
         * Generated time stamps
         */
        protected long[] times;

        /**
         * Number of time stamps to generate on this thread
         */
        protected int iterations;

        /**
         * Constructor for the ClockClient thread.
         *
         * @param timez an array of times generated.
         * @param iterationz the number of time stamps the generate.
         */
        ClockClient(long[] timez, int iterationz) {
            super();
            this.times = timez;
            this.iterations = iterationz;
        }

        /**
         * Run method of this thread generates n-iterations timestamps.
         */
        public void run() {
            for (int i = 0; i < iterations;) {
                try {
                    times[i] = c.getUUIDTime();
                    i++;
                } catch (OverClockedException oce) {
                    overClocks++;
                }
            }
            System.out.println("At End of this thread - Overclocks currently at: " + overClocks);
        }
    }
}
